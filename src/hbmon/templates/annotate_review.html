{% extends "base.html" %}

{% block content %}
<div class="annotate-review-page">
    <div class="review-header">
        <a href="/annotate" class="back-link">‚Üê Back to Annotation</a>
        <h1>Review Observation #{{ observation.id }}</h1>
        <div class="review-meta">
            <span class="species">{{ observation.species_label }}</span>
            <span class="timestamp" data-timestamp="{{ observation.ts_utc }}">{{ observation.ts_utc }}</span>
            {% set review_label = observation.get_extra().get('review', {}).get('label') %}
            {% if review_label == 'true_positive' %}
            <span class="status-badge tp">TP</span>
            {% elif review_label == 'false_positive' %}
            <span class="status-badge fp">FP</span>
            {% endif %}
        </div>
        <!-- Compact help - desktop -->
        <div class="review-help desktop-only">
            <strong>Quick Guide:</strong>
            Draw box = Click & drag | Select = Click box | Move = Drag selected | FP = Check "FP" |
            Delete = Select + Delete key | No bird = Uncheck "Bird present"
        </div>
        <!-- Compact help - mobile -->
        <div class="review-help mobile-help">
            <strong>üì±</strong> Swipe ‚Üê‚Üí to navigate | Long-press box for FP | Use buttons below
        </div>
    </div>

    <div class="review-layout">
        <!-- Frame list sidebar (collapses on mobile) -->
        <aside class="frame-list-sidebar" id="frameSidebar">
            <div class="frame-list-header">
                <h3>Frames</h3>
                <div class="frame-filter">
                    <button class="btn-sm" data-filter="all" onclick="filterFrames('all')">All</button>
                    <button class="btn-sm" data-filter="pending" onclick="filterFrames('pending')">Pending</button>
                    <button class="btn-sm" data-filter="reviewed" onclick="filterFrames('reviewed')">Done</button>
                </div>
            </div>
            <div class="frame-list" id="frameList">
                {% for frame in frames %}
                <div class="frame-item {{ 'active' if frame.id == current_frame.id else '' }}"
                    data-frame-id="{{ frame.id }}" data-status="{{ frame.status }}" onclick="loadFrame({{ frame.id }})">
                    <img data-src="{{ frame.thumbnail_url }}"
                        src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 169'%3E%3Crect width='100%25' height='100%25' fill='%2323243a'/%3E%3C/svg%3E"
                        alt="Frame {{ frame.frame_index }}" class="lazy-thumb" loading="lazy" />
                    <div class="frame-info">
                        <span class="frame-index">#{{ frame.frame_index + 1 }}</span>
                        <span class="frame-status {{ 'reviewed' if frame.status == 'complete' else 'pending' }}">
                            {{ '‚úì' if frame.status == 'complete' else '‚óã' }}
                        </span>
                    </div>
                </div>
                {% endfor %}
            </div>
            <script>
                document.addEventListener('DOMContentLoaded', function () {
                    const lazyImages = document.querySelectorAll('img.lazy-thumb');
                    const observer = new IntersectionObserver((entries, observer) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const img = entry.target;
                                img.src = img.dataset.src;
                                img.classList.remove('lazy-thumb');
                                observer.unobserve(img);
                            }
                        });
                    }, { root: document.getElementById('frameList'), rootMargin: '100px' });

                    lazyImages.forEach(img => observer.observe(img));
                });
            </script>
            <div class="frame-progress">
                <div class="progress-bar">
                    <div class="progress-fill"
                        style="width: {{ (frames_reviewed / frames_total * 100) if frames_total > 0 else 0 }}%"></div>
                </div>
                <span>{{ frames_reviewed }} / {{ frames_total }} reviewed</span>
            </div>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">
            <span>Frames</span>
            <span class="badge">{{ frames_reviewed }}/{{ frames_total }}</span>
        </button>

        <!-- Main editor -->
        <main class="editor-main">
            <div class="canvas-container" id="canvasContainer">
                <canvas id="annotationCanvas"></canvas>
                <img id="frameImage" src="{{ current_frame.image_url if current_frame else '' }}" alt="Frame"
                    crossorigin="anonymous" style="max-width: 100%; height: auto; display: block;" />
                <div class="loading-overlay" id="loadingOverlay">
                    <div style="position: relative; display: flex; align-items: center; justify-content: center;">
                        <div class="spinner"></div>
                        <div id="spinnerTimer" class="spinner-timer">0s</div>
                    </div>
                </div>
            </div>

            <!-- Desktop controls -->
            <div class="editor-controls desktop-only">
                <div class="tool-palette" style="margin-bottom: 1rem;">
                    <h4 style="margin-top:0;">Tools</h4>
                    <div style="display:flex; gap:0.5rem;">
                        <button class="btn btn-sm" onclick="setMode('select')" title="Select/Edit">Select</button>
                        <button class="btn btn-sm" id="btnWand" onclick="setMode('wand')"
                            title="Magic Wand (W) - Find birds in region">ü™Ñ Wand</button>
                    </div>
                </div>
                <hr style="border-color:#3d3e56; margin-bottom:1rem;">

                <div class="truth-toggle">
                    <label class="toggle-label">
                        <input type="checkbox" id="birdPresent" {{ 'checked' if current_frame and
                            current_frame.bird_present else '' }} onchange="toggleBirdPresent()" />
                        <span class="toggle-text">Bird present</span>
                    </label>
                </div>

                <div class="box-list" id="boxList">
                    <div class="inline" style="justify-content: space-between; align-items: center; flex-wrap: wrap;">
                        <h4 style="margin:0;">Boxes</h4>
                        <div class="tidy-controls" style="display:flex; align-items:center; gap:4px;">
                            <select id="tidyIoU" class="form-select-sm"
                                style="width:auto; padding: 2px 4px; font-size: 0.75rem; background: #23243a; color: #fff; border: 1px solid #3d3e56; border-radius: 4px;"
                                title="IoU Threshold">
                                <option value="0.3">0.3</option>
                                <option value="0.4" selected>0.4</option>
                                <option value="0.5">0.5</option>
                                <option value="0.6">0.6</option>
                                <option value="0.7">0.7</option>
                                <option value="0.8">0.8</option>
                                <option value="0.9">0.9</option>
                            </select>
                            <button class="btn btn-sm" onclick="tidyBoxes()"
                                title="Merge overlapping boxes">Tidy</button>
                        </div>
                    </div>
                    <div id="boxItems"></div>
                    <button class="btn btn-sm" onclick="addBox()" style="width:100%; margin-top:0.5rem;">+ Add
                        Box</button>
                </div>

                <div class="action-buttons">
                    <button class="btn" onclick="resetToAuto()">Reset</button>
                    <button class="btn" onclick="clearBoxes()">Clear</button>

                    <div class="save-dropdown-container">
                        <button class="btn btn-primary" id="mainSaveBtn" onclick="handleMainSave()">Save & Next</button>
                        <button class="btn btn-primary dropdown-toggle" onclick="toggleSaveMenu()">‚ñº</button>
                        <div class="save-menu" id="saveMenu">
                            <button onclick="setSaveMode('save-next')">Save & Next (Default)</button>
                            <button onclick="setSaveMode('save-only')">Save Only</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Mobile action bar (fixed bottom, thumb-zone optimized) -->
    <div class="mobile-action-bar">
        <!-- Swipe hint at top -->
        <div class="swipe-hint" id="swipeHint">
            <span class="swipe-arrow left">‚Üê Prev</span>
            <span class="frame-counter" id="frameCounter">1 / {{ frames_total }}</span>
            <span class="swipe-arrow right">Next ‚Üí</span>
        </div>

        <!-- Quick actions row - thumb reachable -->
        <div class="quick-actions-row">
            <button class="quick-action-btn" onclick="toggleBirdPresent()" id="birdToggleBtn">
                <span class="icon">üê¶</span>
                <span class="label" id="birdToggleLabel">Bird: {{ 'Yes' if current_frame and current_frame.bird_present
                    else 'No' }}</span>
            </button>
            <button class="quick-action-btn" onclick="markAllFP()">
                <span class="icon">‚úó</span>
                <span class="label">All FP</span>
            </button>
            <button class="quick-action-btn" onclick="toggleSidebar()">
                <span class="icon">üìã</span>
                <span class="label" id="boxCountLabel">0 boxes</span>
            </button>
        </div>

        <!-- Main action buttons - large, right-aligned for right thumb -->
        <div class="main-actions-row">
            <button class="action-btn secondary" onclick="skipFrame()">
                Skip
            </button>
            <button class="action-btn primary" id="primaryActionBtn" onclick="executePrimaryAction()">
                ‚úì Approve
            </button>
        </div>

        <!-- Floating action menu (slides up) -->
        <div class="floating-menu" id="actionMenu">
            <div class="menu-handle" onclick="toggleActionMenu()"></div>
            <div class="menu-options">
                <button class="menu-option" data-action="approve-advance" onclick="setAction('approve-advance')">
                    <span class="opt-icon">‚úì</span> Approve & Next
                </button>
                <button class="menu-option" data-action="approve-only" onclick="setAction('approve-only')">
                    <span class="opt-icon">‚úì</span> Approve Only
                </button>
                <button class="menu-option" data-action="mark-fp-advance" onclick="setAction('mark-fp-advance')">
                    <span class="opt-icon">‚úó</span> All FP & Next
                </button>
                <button class="menu-option" data-action="no-bird-advance" onclick="setAction('no-bird-advance')">
                    <span class="opt-icon">‚óã</span> No Bird & Next
                </button>
            </div>
        </div>
    </div>

    <!-- Floating menu toggle (bottom right corner - thumb zone) -->
    <button class="fab-menu-toggle" id="fabMenuToggle" onclick="toggleActionMenu()">‚ãÆ</button>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <!-- Desktop keyboard shortcuts -->
    <div class="keyboard-shortcuts desktop-only">
        <span>Shortcuts:</span>
        <kbd>‚Üê</kbd> Prev
        <kbd>‚Üí</kbd> Next
        <kbd>S</kbd> Save
        <kbd>A</kbd> Approve & Advance
        <kbd>K</kbd> Skip
        <kbd>B</kbd> Toggle Bird
        <kbd>W</kbd> Wand
    </div>
</div>

<script>
    const observationId = {{ observation.id }};
    let currentFrameId = {{ current_frame.id if current_frame else 'null' }};
    let boxes = {{ current_frame.box_data | tojson if current_frame else '[]' }};

    // Auto-select Bird Present based on Obs Label for unreviewed frames
    let frameStatus = "{{ current_frame.status if current_frame else 'queued' }}";
    // Parse the JSON provided by python safely
    let obsExtra = {{ observation.extra_json | default ('{}') | safe }};
    let obsLabel = (obsExtra.review && obsExtra.review.label) ? obsExtra.review.label : '';
    console.log("[Annotation] Frame Status:", frameStatus, "Obs Label:", obsLabel, "Boxes:", boxes.length);

    let dbBirdPresent = {{ 'true' if current_frame and current_frame.bird_present else 'false' }};
    let birdPresent = dbBirdPresent;

    if (frameStatus !== 'complete') {
        if (obsLabel === 'true_positive') birdPresent = true;
        else if (obsLabel === 'false_positive') birdPresent = false;

        // Sync UI after load to reflect auto-selected value
        // Sync UI after load to reflect auto-selected value
        document.addEventListener('DOMContentLoaded', () => {
            syncBirdPresentUI();

            // Auto-trigger Magic Wand if TP but no boxes found
            // This happens when the regular detector failed but we know there's a bird
            if (obsLabel === 'true_positive' && boxes.length === 0) {
                console.log("[AutoWand] Triggering auto-wand sequence for TP with no boxes");
                runAutoWandSequence();
            }
        });
    }

    async function runAutoWandSequence() {
        const center = { x: 0.5, y: 0.5 };

        // Helper to check for valid boxes after detection
        const isValidResult = () => {
            tidyBoxes(); // Auto-cleanup non-visible or overlapping boxes
            return boxes.length > 0;
        };

        // Attempt 1: Standard (Fast) - conf=0.15, crop=640
        console.log("[AutoWand] Attempt 1: Standard");
        showToast("Auto-scanning...", false);
        try {
            await triggerWandDetection(center, { confidence: 0.15, crop_size: 640 }, true);
            if (isValidResult()) {
                showToast(`Found ${boxes.length} box(es)!`, true);
                return;
            }
        } catch (e) { console.error("[AutoWand] Attempt 1 failed", e); }

        // Attempt 2: Large - conf=0.1, crop=800
        console.log("[AutoWand] Attempt 2: Large");
        showToast("Expanding search...", false);
        try {
            await triggerWandDetection(center, { confidence: 0.1, crop_size: 800 }, true);
            if (isValidResult()) {
                showToast(`Found ${boxes.length} box(es)!`, true);
                return;
            }
        } catch (e) { console.error("[AutoWand] Attempt 2 failed", e); }

        // Attempt 3: Enhanced Contrast (CLAHE) - conf=0.1, crop=640
        console.log("[AutoWand] Attempt 3: Enhanced Contrast");
        showToast("Enhancing contrast...", false);
        try {
            await triggerWandDetection(center, { confidence: 0.1, crop_size: 640, enhance_contrast: 1 }, true);
            if (isValidResult()) {
                showToast(`Found ${boxes.length} box(es) with enhancement!`, true);
                return;
            }
        } catch (e) { console.error("[AutoWand] Attempt 3 failed", e); }

        // Attempt 4: Rescue (SAHI) - conf=0.05, crop=1024
        console.log("[AutoWand] Attempt 4: Rescue (SAHI)");
        showToast("Deep scan (SAHI)...", false);
        try {
            await triggerWandDetection(center, { confidence: 0.05, crop_size: 1024, use_sahi: 1 }, true);
            if (isValidResult()) {
                showToast(`Found ${boxes.length} box(es)!`, true);
                return;
            }
        } catch (e) { console.error("[AutoWand] Attempt 4 failed", e); }

        // Attempt 5: Deep Rescue (SAHI) - conf=0.01, crop=1280
        console.log("[AutoWand] Attempt 5: Deep Rescue");
        showToast("Final deep scan...", false);
        try {
            await triggerWandDetection(center, { confidence: 0.01, crop_size: 1280, use_sahi: 1 }, true);
            if (isValidResult()) {
                showToast(`Found ${boxes.length} box(es)!`, true);
                return;
            }
        } catch (e) { console.error("[AutoWand] Attempt 5 failed", e); }

        // Final failure - persist message until user clicks
        console.log("[AutoWand] All attempts failed");
        showToast("Could not auto-detect bird. Please annotate manually. (Click to dismiss)", 'warning', true);

        // Re-check bird present toggle - if we failed to find boxes, maybe we should uncheck it?
        // User requested: "Ensure 'Bird present' is only kept if valid boxes remain"
        // But the observation is labelled TP, so there *should* be a bird.
        // We'll leave it checked but with no boxes, prompting manual fix.
    }

    // Dirty state tracking
    let isDirty = false;
    let saveMode = localStorage.getItem('annotationSaveMode') || 'save-next';

    // Wand mode
    let isWandMode = false;

    function markDirty() {
        isDirty = true;
        document.getElementById('mainSaveBtn').textContent = saveMode === 'save-next' ? 'Save & Next *' : 'Save *';
    }

    function markClean() {
        isDirty = false;
        document.getElementById('mainSaveBtn').textContent = saveMode === 'save-next' ? 'Save & Next' : 'Save';
    }

    const canvas = document.getElementById('annotationCanvas');
    const ctx = canvas.getContext('2d');
    const img = document.getElementById('frameImage');

    // Primary action state (persisted in localStorage)
    let primaryAction = localStorage.getItem('annotationPrimaryAction') || 'approve-advance';
    updatePrimaryActionButton();

    // Touch state
    let isTouchDevice = 'ontouchstart' in window;
    let touchStartX, touchStartY;
    let selectedBoxIndex = -1;

    // Canvas setup
    function setupCanvas() {
        if (!img.complete) return;

        const container = document.getElementById('canvasContainer');
        const containerRect = container.getBoundingClientRect();

        // Scale canvas to fit container while maintaining aspect ratio
        const imgAspect = img.naturalWidth / img.naturalHeight;
        const containerAspect = containerRect.width / containerRect.height;

        let displayWidth, displayHeight;
        if (imgAspect > containerAspect) {
            displayWidth = containerRect.width;
            displayHeight = displayWidth / imgAspect;
        } else {
            displayHeight = containerRect.height;
            displayWidth = displayHeight * imgAspect;
        }

        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;

        img.style.width = displayWidth + 'px';
        img.style.height = displayHeight + 'px';

        drawBoxes();
    }

    img.onload = setupCanvas;
    window.addEventListener('resize', setupCanvas);
    setupCanvas();

    function getBoxColor(idx) {
        const hue = (idx * 137.508) % 360;
        return {
            solid: `hsl(${hue}, 80%, 50%)`,
            alpha: `hsla(${hue}, 80%, 50%, 0.2)`
        };
    }

    // Drawing
    function drawBoxes() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        boxes.forEach((box, idx) => {
            if (!box || isNaN(box.x) || box.w <= 0.001) return;
            const x = (box.x - box.w / 2) * canvas.width;
            const y = (box.y - box.h / 2) * canvas.height;
            const w = box.w * canvas.width;
            const h = box.h * canvas.height;

            const isSelected = idx === selectedBoxIndex;
            const colors = getBoxColor(idx);

            ctx.strokeStyle = colors.solid;
            ctx.lineWidth = isSelected ? 4 : 3;
            ctx.strokeRect(x, y, w, h);

            ctx.fillStyle = colors.alpha;
            ctx.fillRect(x, y, w, h);

            // Label with background for readability (includes confidence if available)
            const confStr = box.confidence != null ? ` ${(box.confidence * 100).toFixed(0)}%` : '';
            const label = `#${idx + 1}${confStr}${box.is_false_positive ? ' (FP)' : ''}`;
            ctx.font = 'bold 20px sans-serif';
            const textMetrics = ctx.measureText(label);
            const textWidth = textMetrics.width;
            const textHeight = 24; // approx height

            // Draw label background
            ctx.fillStyle = colors.solid;
            ctx.fillRect(x, y - textHeight, textWidth + 10, textHeight);

            // Draw text
            ctx.fillStyle = '#fff';
            ctx.textBaseline = 'bottom';
            ctx.fillText(label, x + 5, y - 4);

            // Draw strikethrough "X" for FP boxes
            if (box.is_false_positive) {
                ctx.beginPath();
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 4; // Thicker for better visibility
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y + h);
                ctx.moveTo(x + w, y);
                ctx.lineTo(x, y + h);
                ctx.stroke();
            }

            // Draw resize handles for selected box
            if (isSelected) {
                drawResizeHandles(x, y, w, h);
            }
        });
        updateBoxList();
        updateBoxCount();
    }

    function drawResizeHandles(x, y, w, h) {
        const handleSize = isTouchDevice ? 24 : 12;
        ctx.fillStyle = '#fff';
        // Corners
        ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        ctx.fillRect(x + w - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        ctx.fillRect(x - handleSize / 2, y + h - handleSize / 2, handleSize, handleSize);
        ctx.fillRect(x + w - handleSize / 2, y + h - handleSize / 2, handleSize, handleSize);
    }

    function updateBoxList() {
        const container = document.getElementById('boxItems');
        if (!container) return;
        container.innerHTML = boxes.map((box, idx) => {
            const colors = getBoxColor(idx);
            const confBadge = box.confidence != null ? `<span class="badge" style="background: #555; color: #fff; margin-left: 4px; font-size: 0.8em;">${(box.confidence * 100).toFixed(0)}%</span>` : '';
            return `
            <div class="box-item ${box.is_false_positive ? 'false-positive' : ''} ${idx === selectedBoxIndex ? 'selected' : ''}"
                 onclick="selectBox(${idx})"
                 style="border-left: 5px solid ${colors.solid};">
                <span class="badge" style="background: ${colors.solid}; color: #fff; margin-right: 8px;">#${idx + 1}</span>
                <span style="flex: 1;">Box #${idx + 1}${confBadge}</span>
                <label onclick="event.stopPropagation()">
                    <input type="checkbox" ${box.is_false_positive ? 'checked' : ''} onchange="toggleFP(${idx})"> FP
                </label>
                <button class="btn-sm" onclick="event.stopPropagation(); deleteBox(${idx})">√ó</button>
            </div>
        `;
        }).join('');
    }

    function updateBoxCount() {
        const countEl = document.getElementById('boxCount');
        if (countEl) {
            const fpCount = boxes.filter(b => b.is_false_positive).length;
            const realCount = boxes.length - fpCount;
            countEl.textContent = `${realCount} box${realCount !== 1 ? 'es' : ''}${fpCount ? ` (+${fpCount} FP)` : ''}`;
        }
    }

    // Mouse events
    let isDrawing = false;
    let isDragging = false;
    let isResizing = false;
    let startX, startY;
    let dragOffset = { x: 0, y: 0 };

    function getCanvasCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    function findBoxAtPoint(px, py) {
        for (let i = boxes.length - 1; i >= 0; i--) {
            const box = boxes[i];
            const x1 = (box.x - box.w / 2) * canvas.width;
            const y1 = (box.y - box.h / 2) * canvas.height;
            const x2 = x1 + box.w * canvas.width;
            const y2 = y1 + box.h * canvas.height;

            if (px >= x1 && px <= x2 && py >= y1 && py <= y2) {
                return i;
            }
        }
        return -1;
    }

    function findResizeHandle(px, py) {
        if (selectedBoxIndex < 0) return null;
        const box = boxes[selectedBoxIndex];
        const x = (box.x - box.w / 2) * canvas.width;
        const y = (box.y - box.h / 2) * canvas.height;
        const w = box.w * canvas.width;
        const h = box.h * canvas.height;
        const handleSize = isTouchDevice ? 30 : 15; // Slightly larger hit area

        const corners = [
            { name: 'tl', x: x, y: y },
            { name: 'tr', x: x + w, y: y },
            { name: 'bl', x: x, y: y + h },
            { name: 'br', x: x + w, y: y + h }
        ];

        for (const corner of corners) {
            if (Math.abs(px - corner.x) < handleSize && Math.abs(py - corner.y) < handleSize) {
                return corner.name;
            }
        }
        return null;
    }

    canvas.addEventListener('mousedown', handlePointerDown);
    canvas.addEventListener('mousemove', handlePointerMove);
    window.addEventListener('mouseup', handlePointerUp);

    // Touch events
    canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
    canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
    window.addEventListener('touchend', handlePointerUp, { passive: false });

    function handlePointerDown(e) {
        e.preventDefault();
        const coords = getCanvasCoords(e);
        startX = coords.x;
        startY = coords.y;

        // Handle wand mode - click to detect
        if (isWandMode) {
            triggerWandDetection(coords);
            return;
        }

        // 1. Check for resize handles first (if a box is selected)
        const handle = findResizeHandle(coords.x, coords.y);
        if (handle) {
            isResizing = handle;
            return;
        }

        // 2. Check for box selection/dragging
        const boxIdx = findBoxAtPoint(coords.x, coords.y);
        if (boxIdx >= 0) {
            selectedBoxIndex = boxIdx;
            isDragging = true;
            const box = boxes[boxIdx];
            dragOffset.x = coords.x - box.x * canvas.width;
            dragOffset.y = coords.y - box.y * canvas.height;
        } else {
            selectedBoxIndex = -1;
            isDrawing = true;
        }
        drawBoxes();
    }

    function handlePointerMove(e) {
        e.preventDefault();
        const coords = getCanvasCoords(e);

        if (isResizing && selectedBoxIndex >= 0) {
            const box = boxes[selectedBoxIndex];
            let x1 = (box.x - box.w / 2) * canvas.width;
            let y1 = (box.y - box.h / 2) * canvas.height;
            let x2 = x1 + box.w * canvas.width;
            let y2 = y1 + box.h * canvas.height;

            if (isResizing === 'tl') { x1 = coords.x; y1 = coords.y; }
            if (isResizing === 'tr') { x2 = coords.x; y1 = coords.y; }
            if (isResizing === 'bl') { x1 = coords.x; y2 = coords.y; }
            if (isResizing === 'br') { x2 = coords.x; y2 = coords.y; }

            // Convert back to center format
            const newW = Math.abs(x2 - x1);
            const newH = Math.abs(y2 - y1);
            box.w = newW / canvas.width;
            box.h = newH / canvas.height;
            box.x = (Math.min(x1, x2) + newW / 2) / canvas.width;
            box.y = (Math.min(y1, y2) + newH / 2) / canvas.height;
            markDirty();
            drawBoxes();
        } else if (isDragging && selectedBoxIndex >= 0) {
            // Move selected box
            const box = boxes[selectedBoxIndex];
            box.x = (coords.x - dragOffset.x) / canvas.width;
            box.y = (coords.y - dragOffset.y) / canvas.height;
            // Clamp to canvas
            box.x = Math.max(box.w / 2, Math.min(1 - box.w / 2, box.x));
            box.y = Math.max(box.h / 2, Math.min(1 - box.h / 2, box.y));
            markDirty();
            drawBoxes();
        } else if (isDrawing) {
            // Draw new box preview
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoxes();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(startX, startY, coords.x - startX, coords.y - startY);
            ctx.setLineDash([]);
        }

        // Cursor feedback
        if (!isDrawing && !isDragging && !isResizing) {
            if (isWandMode) {
                canvas.style.cursor = 'cell';  // Magic wand cursor
            } else {
                const handle = findResizeHandle(coords.x, coords.y);
                const boxIdx = findBoxAtPoint(coords.x, coords.y);

                if (handle) {
                    canvas.style.cursor = (handle === 'tl' || handle === 'br') ? 'nwse-resize' : 'nesw-resize';
                } else if (boxIdx >= 0) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
        }
    }

    function handlePointerUp(e) {
        if (isDrawing) {
            const coords = getCanvasCoords(e);
            const w = Math.abs(coords.x - startX);
            const h = Math.abs(coords.y - startY);

            // Minimum size for new box
            const minSize = isTouchDevice ? 30 : 10;
            if (w > minSize && h > minSize) {
                const cx = (Math.min(startX, coords.x) + w / 2) / canvas.width;
                const cy = (Math.min(startY, coords.y) + h / 2) / canvas.height;
                boxes.push({
                    class_id: 0,
                    x: cx,
                    y: cy,
                    w: w / canvas.width,
                    h: h / canvas.height,
                    is_false_positive: false,
                    source: 'manual'
                });
                selectedBoxIndex = boxes.length - 1;
                markDirty();
            }
        }

        isDrawing = false;
        isDragging = false;
        isResizing = false;
        drawBoxes();
    }

    // Long press for FP toggle on touch
    let longPressTimer;
    canvas.addEventListener('touchstart', (e) => {
        const coords = getCanvasCoords(e);
        const boxIdx = findBoxAtPoint(coords.x, coords.y);
        if (boxIdx >= 0) {
            longPressTimer = setTimeout(() => {
                toggleFP(boxIdx);
                showToast(`Box #${boxIdx + 1} ${boxes[boxIdx].is_false_positive ? 'marked as FP' : 'unmarked'}`);
            }, 500);
        }
    });

    canvas.addEventListener('touchend', () => {
        clearTimeout(longPressTimer);
    });

    canvas.addEventListener('touchmove', () => {
        clearTimeout(longPressTimer);
    });

    // Actions
    function selectBox(idx) {
        selectedBoxIndex = idx;
        drawBoxes();
    }

    function toggleFP(idx) {
        boxes[idx].is_false_positive = !boxes[idx].is_false_positive;
        markDirty();
        drawBoxes();
    }

    function deleteBox(idx) {
        boxes.splice(idx, 1);
        if (selectedBoxIndex >= boxes.length) {
            selectedBoxIndex = boxes.length - 1;
        }
        markDirty();
        drawBoxes();
    }

    function addBox() {
        // Exit wand mode when adding box manually
        if (isWandMode) {
            setMode('select');
        }
        boxes.push({
            class_id: 0,
            x: 0.5,
            y: 0.5,
            w: 0.2,
            h: 0.2,
            is_false_positive: false,
            source: 'manual'
        });
        selectedBoxIndex = boxes.length - 1;
        markDirty();
        drawBoxes();
    }

    function clearBoxes() {
        boxes = [];
        selectedBoxIndex = -1;
        markDirty();
        drawBoxes();
    }

    function resetToAuto() {
        // ... handled in fetch, just markDirty after
        fetch(`/api/annotate/${observationId}/frame/${currentFrameId}`)
            .then(r => r.json())
            .then(data => {
                boxes = data.boxes || [];
                // Respect auto-select logic again or keep DB? User asked for reset.
                // Reset usually means reset to DB state.
                birdPresent = data.bird_present || false;
                syncBirdPresentUI();
                selectedBoxIndex = -1;
                markDirty(); // Technically dirty compared to previous state, or maybe clean if reset to DB? 
                // Let's mark dirty to force manual save if they change their mind
                drawBoxes();
            });
    }

    function toggleBirdPresent() {
        birdPresent = !birdPresent;
        syncBirdPresentUI();
        markDirty();
    }

    function syncBirdPresentUI() {
        const desktop = document.getElementById('birdPresent');
        if (desktop) desktop.checked = birdPresent;
        // Also update mobile UI label
        updateBirdToggleLabel();
    }

    // Magic wand configuration (passed from server)
    const WAND_TIMEOUT_SECONDS = {{ wand_timeout | default (60) }};
    const WAND_MAX_RETRIES = {{ wand_retries | default (1) }};

    async function triggerWandDetection(coords, params = {}, silentStart = false) {
        const spinner = document.getElementById('loadingOverlay');
        const timerText = document.getElementById('spinnerTimer');
        let timerInterval = null;
        let startTime = Date.now();

        if (spinner) {
            spinner.classList.add('visible');
            if (timerText) {
                timerText.textContent = "0s";
                timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    timerText.textContent = `${elapsed}s`;
                }, 1000);
            }
        }

        let attempt = 0;
        const maxAttempts = WAND_MAX_RETRIES + 1;

        try {
            while (attempt < maxAttempts) {
                attempt++;

                if (!silentStart) {
                    if (attempt === 1) {
                        showToast('Scanning region...', false);
                    } else {
                        showToast(`Retrying detection (attempt ${attempt}/${maxAttempts})...`, false);
                    }
                }

                // Step 1: Submit detection job
                const body = { ...coords, ...params };
                const res = await fetch(`/api/annotate/${observationId}/frame/${currentFrameId}/detect_region`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!res.ok) throw new Error("Failed to submit detection job");

                const data = await res.json();

                // Check if queue is available
                if (data.error) {
                    if (!silentStart) showToast(data.error, true);
                    return 0; // Return 0 boxes on error
                }

                const jobId = data.job_id;
                if (!jobId) {
                    if (!silentStart) showToast('Detection failed: no job ID', true);
                    return 0;
                }

                // Step 2: Poll for job completion with timeout
                const pollIntervalMs = 500;
                const maxPollTime = WAND_TIMEOUT_SECONDS * 1000;
                let elapsed = 0;
                let jobResult = null;

                while (elapsed < maxPollTime) {
                    const statusRes = await fetch(`/api/annotate/wand_job/${jobId}`);
                    if (!statusRes.ok) break;

                    const statusData = await statusRes.json();
                    if (statusData.status === 'finished') {
                        jobResult = statusData;
                        break;
                    } else if (statusData.status === 'failed') {
                        throw new Error(statusData.error || "Job failed");
                    }

                    await new Promise(r => setTimeout(r, pollIntervalMs));
                    elapsed += pollIntervalMs;
                }

                if (jobResult) {
                    const newBoxes = jobResult.boxes || [];

                    // Add new boxes
                    if (newBoxes.length > 0) {
                        newBoxes.forEach(b => {
                            const box = {
                                x: b.x1,
                                y: b.y1,
                                w: b.x2 - b.x1,
                                h: b.y2 - b.y1,
                                label: b.label || 'bird',
                                confidence: b.confidence,
                                is_false_positive: false,
                                source: 'wand'
                            };
                            boxes.push(box);
                        });
                        drawBoxes();
                        hasUnsavedChanges = true;
                        if (!silentStart) showToast(`Found ${newBoxes.length} object(s)!`, true);
                    } else {
                        if (!silentStart) showToast('No objects found in region.', true);
                    }

                    return newBoxes.length;

                } else {
                    // Timeout?
                    if (attempt === maxAttempts) {
                        throw new Error("Detection timed out. (Click to dismiss)");
                    }
                }
            }
        } catch (err) {
            console.error(err);
            if (!silentStart) {
                const isTimeout = err.message.includes('timed out');
                showToast(`Error: ${err.message}`, 'error', isTimeout || true);
            }
        } finally {
            if (spinner) spinner.classList.remove('visible');
            if (timerInterval) clearInterval(timerInterval);
        }
        return 0;
    }


    function setMode(mode) {
        if (mode === 'wand') {
            isWandMode = true;
        } else {
            isWandMode = false;
        }

        const canvasContainer = document.getElementById('canvasContainer');
        if (isWandMode) {
            canvasContainer.classList.add('wand-mode');
            selectedBoxIndex = -1;
            drawBoxes();
            showToast('Magic Wand: Click on location to scan');
        } else {
            canvasContainer.classList.remove('wand-mode');
        }

        const btnWand = document.getElementById('btnWand');
        if (btnWand) {
            if (isWandMode) {
                btnWand.classList.remove('btn');
                btnWand.classList.add('btn-primary');
            } else {
                btnWand.classList.add('btn');
                btnWand.classList.remove('btn-primary');
            }
        }
    }

    // Save and navigation

    let saveMenuOpen = false;

    function toggleSaveMenu() {
        saveMenuOpen = !saveMenuOpen;
        document.getElementById('saveMenu').classList.toggle('visible', saveMenuOpen);
    }

    function setSaveMode(mode) {
        saveMode = mode;
        localStorage.setItem('annotationSaveMode', mode);
        const btn = document.getElementById('mainSaveBtn');
        btn.textContent = mode === 'save-next' ? 'Save & Next' : 'Save';
        if (isDirty) btn.textContent += ' *';
        toggleSaveMenu();
    }

    // Close save menu when clicking outside
    window.addEventListener('click', (e) => {
        if (!e.target.closest('.save-dropdown-container')) {
            document.getElementById('saveMenu').classList.remove('visible');
            saveMenuOpen = false;
        }
    });

    function handleMainSave() {
        saveFrame(saveMode === 'save-next');
    }

    async function saveFrame(advance = false) {
        const response = await fetch(`/api/annotate/${observationId}/frame/${currentFrameId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                bird_present: birdPresent,
                boxes: boxes
            })
        });

        if (response.ok) {
            markClean();
            const frameItem = document.querySelector(`.frame-item[data-frame-id="${currentFrameId}"]`);
            if (frameItem) {
                frameItem.classList.add('saved');
                frameItem.dataset.status = 'complete';
                const statusEl = frameItem.querySelector('.frame-status');
                if (statusEl) statusEl.textContent = '‚úì';
            }
            showToast('Saved ‚úì');

            if (advance) {
                goNextPending();
            }
        } else {
            showToast('Save failed!', 'error');
        }
    }

    function skipFrame() {
        if (!checkDirty()) return;
        goNextPending();
    }

    function checkDirty() {
        if (isDirty) {
            if (!confirm('You have unsaved changes. Do you want to discard them?')) {
                return false;
            }
        }
        return true;
    }

    // Window close warning
    window.addEventListener('beforeunload', (e) => {
        if (isDirty) {
            e.preventDefault();
            e.returnValue = '';
        }
    });

    function goNextPending() {
        const items = Array.from(document.querySelectorAll('.frame-item'));
        const currentIdx = items.findIndex(i => i.classList.contains('active'));

        // Find next pending frame
        for (let i = currentIdx + 1; i < items.length; i++) {
            if (items[i].dataset.status !== 'complete') {
                loadFrame(items[i].dataset.frameId);
                return;
            }
        }

        // No more pending, go to next anyway or show completion
        if (currentIdx < items.length - 1) {
            loadFrame(items[currentIdx + 1].dataset.frameId);
        } else {
            showToast('All frames reviewed! üéâ');
        }
    }

    function loadFrame(frameId) {
        if (frameId == currentFrameId) return;
        if (!checkDirty()) return;
        window.location.href = `/annotate/${observationId}?frame=${frameId}`;
    }

    function goPrev() {
        const items = Array.from(document.querySelectorAll('.frame-item'));
        const currentIdx = items.findIndex(i => i.classList.contains('active'));
        if (currentIdx > 0) {
            loadFrame(items[currentIdx - 1].dataset.frameId);
        }
    }

    function goNext() {
        const items = Array.from(document.querySelectorAll('.frame-item'));
        const currentIdx = items.findIndex(i => i.classList.contains('active'));
        if (currentIdx < items.length - 1) {
            loadFrame(items[currentIdx + 1].dataset.frameId);
        }
    }

    function filterFrames(filter) {
        document.querySelectorAll('.frame-item').forEach(item => {
            const status = item.dataset.status;
            if (filter === 'all') {
                item.style.display = '';
            } else if (filter === 'pending' && status !== 'complete') {
                item.style.display = '';
            } else if (filter === 'reviewed' && status === 'complete') {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });

        // Update active filter button
        document.querySelectorAll('.frame-filter .btn-sm').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.filter === filter);
        });
    }

    // Primary action handling
    function setAction(action) {
        primaryAction = action;
        localStorage.setItem('annotationPrimaryAction', action);
        updatePrimaryActionButton();
        toggleActionMenu(false);
    }

    function updatePrimaryActionButton() {
        const btn = document.getElementById('primaryActionBtn');
        if (!btn) return;

        const labels = {
            'approve-advance': '‚úì Approve & Advance',
            'approve-only': '‚úì Approve Only',
            'mark-fp-advance': '‚úó Mark All FP & Advance',
            'no-bird-advance': '‚óã No Bird & Advance'
        };
        btn.textContent = labels[primaryAction] || labels['approve-advance'];

        // Update menu selection
        document.querySelectorAll('.action-option').forEach(opt => {
            opt.classList.toggle('selected', opt.dataset.action === primaryAction);
        });
    }

    function executePrimaryAction() {
        switch (primaryAction) {
            case 'approve-advance':
                saveFrame(true);
                break;
            case 'approve-only':
                saveFrame(false);
                break;
            case 'mark-fp-advance':
                boxes.forEach(box => box.is_false_positive = true);
                birdPresent = true; // Bird IS present, boxes are just wrong detections
                syncBirdPresentUI();
                saveFrame(true);
                break;
            case 'no-bird-advance':
                birdPresent = false;
                syncBirdPresentUI();
                saveFrame(true);
                break;
        }
    }

    function toggleActionMenu(show) {
        const menu = document.getElementById('actionMenu');
        if (show === undefined) {
            menu.classList.toggle('visible');
        } else {
            menu.classList.toggle('visible', show);
        }
    }

    // Sidebar toggle (mobile)
    function toggleSidebar() {
        document.getElementById('frameSidebar').classList.toggle('visible');
    }

    // Toast notifications
    function showToast(message, type = 'success', persist = false) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.className = `toast ${type} visible`;

        // Clear any existing timeout
        if (toast._hideTimeout) {
            clearTimeout(toast._hideTimeout);
            toast._hideTimeout = null;
        }

        if (persist) {
            // Add click handler to dismiss
            const dismissHandler = () => {
                toast.classList.remove('visible');
                toast.removeEventListener('click', dismissHandler);
            };
            toast.addEventListener('click', dismissHandler);
            toast.style.cursor = 'pointer';
        } else {
            toast.style.cursor = 'default';
            toast._hideTimeout = setTimeout(() => {
                toast.classList.remove('visible');
            }, 2000);
        }
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;
        switch (e.key) {
            case 'ArrowLeft': goPrev(); break;
            case 'ArrowRight': goNext(); break;
            case 's': case 'S': handleMainSave(); break;
            case 'a': case 'A': executePrimaryAction(); break;
            case 'k': case 'K': skipFrame(); break;
            case 'c': case 'C': clearBoxes(); break;
            case 'r': case 'R': resetToAuto(); break;
            case 'b': case 'B': toggleBirdPresent(); break;
            case 'w': case 'W': setMode(isWandMode ? 'select' : 'wand'); break;
            case 'Delete': case 'Backspace':
                if (selectedBoxIndex >= 0) {
                    deleteBox(selectedBoxIndex);
                }
                break;
            case 'f': case 'F':
                if (selectedBoxIndex >= 0) {
                    toggleFP(selectedBoxIndex);
                }
                break;
        }
    });

    // Mobile swipe gestures for navigation
    let swipeStartX = 0;
    let swipeStartY = 0;
    const SWIPE_THRESHOLD = 80;

    document.addEventListener('touchstart', (e) => {
        // Only track swipes on canvas area
        if (!e.target.closest('.canvas-container')) return;
        swipeStartX = e.touches[0].clientX;
        swipeStartY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
        if (swipeStartX === 0) return;

        const deltaX = e.changedTouches[0].clientX - swipeStartX;
        const deltaY = e.changedTouches[0].clientY - swipeStartY;

        // Only horizontal swipes
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > SWIPE_THRESHOLD) {
            if (deltaX > 0) {
                goPrev();
                showSwipeHint('left');
            } else {
                goNext();
                showSwipeHint('right');
            }
        }

        swipeStartX = 0;
        swipeStartY = 0;
    }, { passive: true });

    function showSwipeHint(direction) {
        const hint = document.getElementById('swipeHint');
        if (!hint) return;
        hint.classList.add('active');
        hint.querySelector(`.swipe-arrow.${direction}`)?.classList.add('highlight');
        setTimeout(() => {
            hint.classList.remove('active');
            hint.querySelectorAll('.swipe-arrow').forEach(el => el.classList.remove('highlight'));
        }, 300);
    }

    // Mark all boxes as false positive
    function markAllFP() {
        boxes.forEach(box => box.is_false_positive = true);
        drawBoxes();
        showToast('All boxes marked FP');
    }

    // Update frame counter
    function updateFrameCounter() {
        const items = document.querySelectorAll('.frame-item');
        const currentIdx = Array.from(items).findIndex(i => i.classList.contains('active'));
        const counter = document.getElementById('frameCounter');
        if (counter) {
            counter.textContent = `${currentIdx + 1} / ${items.length}`;
        }
    }

    // Update box count in mobile UI
    function updateBoxCount() {
        const fpCount = boxes.filter(b => b.is_false_positive).length;
        const realCount = boxes.length - fpCount;

        const countLabel = document.getElementById('boxCountLabel');
        if (countLabel) {
            countLabel.textContent = `${boxes.length} box${boxes.length !== 1 ? 'es' : ''}`;
        }
    }

    // Update bird toggle label
    function updateBirdToggleLabel() {
        const label = document.getElementById('birdToggleLabel');
        if (label) {
            label.textContent = `Bird: ${birdPresent ? 'Yes' : 'No'}`;
        }
        const btn = document.getElementById('birdToggleBtn');
        if (btn) {
            btn.classList.toggle('active', birdPresent);
        }
    }

    // FAB menu toggle with backdrop
    function toggleActionMenu(show) {
        const menu = document.getElementById('actionMenu');
        const fab = document.getElementById('fabMenuToggle');

        if (show === undefined) {
            menu.classList.toggle('visible');
        } else {
            menu.classList.toggle('visible', show);
        }

        if (fab) {
            fab.classList.toggle('active', menu.classList.contains('visible'));
        }
    }

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.floating-menu') && !e.target.closest('.fab-menu-toggle')) {
            toggleActionMenu(false);
        }
    });

    function getOverlapMetrics(b1, b2) {
        const x1min = b1.x - b1.w / 2, y1min = b1.y - b1.h / 2;
        const x1max = b1.x + b1.w / 2, y1max = b1.y + b1.h / 2;
        const x2min = b2.x - b2.w / 2, y2min = b2.y - b2.h / 2;
        const x2max = b2.x + b2.w / 2, y2max = b2.y + b2.h / 2;
        const xIm = Math.max(x1min, x2min), yIm = Math.max(y1min, y2min);
        const xIx = Math.min(x1max, x2max), yIx = Math.min(y1max, y2max);
        const iw = Math.max(0, xIx - xIm), ih = Math.max(0, yIx - yIm);
        const iA = iw * ih;

        const area1 = b1.w * b1.h;
        const area2 = b2.w * b2.h;
        const uA = area1 + area2 - iA;

        const iou = uA > 0 ? iA / uA : 0;
        const smallerArea = Math.min(area1, area2);
        const containment = smallerArea > 0 ? iA / smallerArea : 0;

        return { iou, containment };
    }

    function tidyBoxes() {
        if (!boxes.length) return;
        const threshold = parseFloat(document.getElementById('tidyIoU').value) || 0.4;
        const countBefore = boxes.length;

        // 1. Remove tiny boxes
        boxes = boxes.filter(b => (b.w * b.h) >= 0.0001);

        if (boxes.length > 1) {
            // 2. Simple NMS with confidence propagation
            const sorted = boxes.slice().sort((a, b) => (b.confidence || 1) - (a.confidence || 1));
            const kept = [];
            while (sorted.length > 0) {
                const head = sorted.shift();
                kept.push(head);
                for (let i = 0; i < sorted.length; i++) {
                    const metrics = getOverlapMetrics(head, sorted[i]);
                    if (metrics.iou > threshold || metrics.containment > 0.8) {
                        // Propagate highest confidence before removing merged box
                        if ((sorted[i].confidence || 0) > (head.confidence || 0)) {
                            head.confidence = sorted[i].confidence;
                        }
                        sorted.splice(i, 1);
                        i--;
                    }
                }
            }
            boxes = kept;
        }

        const removed = countBefore - boxes.length;
        if (removed > 0) {
            selectedBoxIndex = -1;
            markDirty();
            drawBoxes();
            showToast(`Tidied: removed ${removed} box${removed > 1 ? 'es' : ''}`);
        } else {
            showToast('Already tidy');
        }
    }

    // Initialize mobile UI
    updateFrameCounter();
    updateBirdToggleLabel();
</script>

<style>
    :root {
        --action-bar-height: 120px;
    }

    .annotate-review-page {
        height: calc(100vh - 120px);
        display: flex;
        flex-direction: column;
    }

    .review-header {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid var(--border);
    }

    .back-link {
        color: var(--muted);
        text-decoration: none;
        font-size: 0.875rem;
    }

    .review-header h1 {
        margin: 0.25rem 0;
        font-size: 1.25rem;
    }

    .review-meta {
        font-size: 0.75rem;
        color: var(--muted);
    }

    .review-help {
        font-size: 0.75rem;
        color: var(--muted);
        background: var(--surface);
        padding: 0.5rem 0.75rem;
        border-radius: 6px;
        margin-top: 0.5rem;
    }

    .mobile-help {
        display: none;
    }

    .review-meta .species {
        color: #a0a0b0;
    }

    .review-meta .status-badge {
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: bold;
        margin-left: 8px;
    }

    .review-meta .status-badge.tp {
        background: rgba(46, 204, 113, 0.2);
        color: #2ecc71;
        border: 1px solid #2ecc71;
    }

    .review-meta .status-badge.fp {
        background: rgba(231, 76, 60, 0.2);
        color: #e74c3c;
        border: 1px solid #e74c3c;
    }

    .save-dropdown-container {
        position: relative;
        display: inline-flex;
    }

    .save-dropdown-container .dropdown-toggle {
        margin-left: 1px;
        padding-left: 6px;
        padding-right: 6px;
    }

    .save-menu {
        position: absolute;
        bottom: 100%;
        right: 0;
        background: #23243a;
        border: 1px solid #3d3e56;
        border-radius: 4px;
        margin-bottom: 4px;
        display: none;
        flex-direction: column;
        min-width: 180px;
        z-index: 100;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .save-menu.visible {
        display: flex;
    }

    .save-menu button {
        background: transparent;
        border: none;
        color: #fff;
        padding: 8px 12px;
        text-align: left;
        cursor: pointer;
        width: 100%;
    }

    .save-menu button:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    .canvas-container.wand-mode {
        cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M14.5 9.5L20 4m-6 6l-3 3-2.5-1-1 3.5 3.5-1 1-2.5 3 3"></path></svg>') 0 24, crosshair;
    }

    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        display: none;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 1000;
    }

    .loading-overlay.visible {
        display: flex;
    }

    .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #fff;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .spinner-timer {
        position: absolute;
        font-size: 0.7rem;
        font-weight: bold;
        color: white;
        pointer-events: none;
    }

    .review-layout {
        flex: 1;
        display: flex;
        overflow: hidden;
        position: relative;
    }

    /* Frame sidebar */
    .frame-list-sidebar {
        width: 180px;
        border-right: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        background: var(--bg);
        z-index: 100;
    }

    .frame-list-header {
        padding: 0.5rem;
        border-bottom: 1px solid var(--border);
    }

    .frame-list-header h3 {
        margin: 0 0 0.5rem;
        font-size: 0.875rem;
    }

    .frame-filter {
        display: flex;
        gap: 0.25rem;
    }

    .frame-filter .btn-sm.active {
        background: var(--accent);
        color: white;
    }

    .frame-list {
        flex: 1;
        overflow-y: auto;
    }

    .frame-item {
        display: flex;
        padding: 0.5rem;
        cursor: pointer;
        border-bottom: 1px solid var(--border);
        min-height: 48px;
        align-items: center;
    }

    .frame-item:hover {
        background: var(--surface);
    }

    .frame-item.active {
        background: var(--accent-bg);
        border-left: 3px solid var(--accent);
    }

    .frame-item.saved {
        background: rgba(78, 205, 196, 0.1);
    }

    .frame-item img {
        width: 50px;
        height: 35px;
        object-fit: cover;
        border-radius: 4px;
    }

    .frame-info {
        flex: 1;
        margin-left: 0.5rem;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .frame-index {
        font-size: 0.875rem;
    }

    .frame-status {
        font-size: 0.75rem;
        color: var(--muted);
    }

    .frame-status.reviewed {
        color: var(--success);
    }

    .frame-progress {
        padding: 0.5rem;
        border-top: 1px solid var(--border);
        font-size: 0.75rem;
    }

    .sidebar-toggle {
        display: none;
    }

    /* Editor main */
    .editor-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 0.5rem;
        overflow: hidden;
    }

    .canvas-container {
        flex: 1;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #111;
        border-radius: 8px;
        overflow: hidden;
        touch-action: none;
    }

    .canvas-container img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
    }

    .canvas-container canvas {
        position: absolute;
        pointer-events: auto;
        touch-action: none;
    }

    .editor-controls {
        padding: 0.75rem 0;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: flex-start;
    }

    .truth-toggle {
        flex: 0 0 auto;
    }

    .toggle-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        padding: 0.5rem;
        min-height: 48px;
    }

    .box-list {
        flex: 1;
    }

    .box-list h4 {
        margin: 0 0 0.5rem;
        font-size: 0.875rem;
    }

    .box-item {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem 0.5rem;
        background: var(--surface);
        border-radius: 4px;
        margin: 0.25rem;
        cursor: pointer;
        min-height: 36px;
    }

    .box-item.selected {
        outline: 2px solid var(--accent);
    }

    .box-item.false-positive {
        background: rgba(255, 107, 107, 0.1);
        border: 1px dashed #ff6b6b;
    }

    .box-item.false-positive span {
        text-decoration: line-through;
        color: #ff6b6b;
    }

    .action-buttons {
        display: flex;
        gap: 0.5rem;
    }

    /* Mobile action bar - thumb-zone optimized */
    .mobile-action-bar {
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg);
        border-top: 1px solid var(--border);
        padding: 0.5rem;
        padding-bottom: max(0.5rem, env(safe-area-inset-bottom));
        z-index: 200;
    }

    .swipe-hint {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        color: var(--muted);
        opacity: 0.6;
        transition: opacity 0.2s;
    }

    .swipe-hint.active {
        opacity: 1;
    }

    .swipe-arrow {
        transition: color 0.2s, transform 0.2s;
    }

    .swipe-arrow.highlight {
        color: var(--accent);
        transform: scale(1.2);
    }

    .frame-counter {
        font-weight: 600;
    }

    .quick-actions-row {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }

    .quick-action-btn {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 0.5rem;
        min-height: 56px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
    }

    .quick-action-btn:active {
        transform: scale(0.95);
        background: var(--accent-bg);
    }

    .quick-action-btn.active {
        background: var(--accent-bg);
        border-color: var(--accent);
    }

    .quick-action-btn .icon {
        font-size: 1.25rem;
        margin-bottom: 0.25rem;
    }

    .quick-action-btn .label {
        font-size: 0.7rem;
        color: var(--muted);
    }

    .main-actions-row {
        display: flex;
        gap: 0.5rem;
    }

    .action-btn {
        flex: 1;
        min-height: 56px;
        font-size: 1.1rem;
        font-weight: 600;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.15s;
    }

    .action-btn:active {
        transform: scale(0.97);
    }

    .action-btn.secondary {
        background: var(--surface);
        color: var(--fg);
        flex: 0 0 80px;
    }

    .action-btn.primary {
        background: var(--accent);
        color: white;
    }

    /* Floating action menu */
    .floating-menu {
        display: none;
        position: fixed;
        bottom: 180px;
        right: 1rem;
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 16px;
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
        overflow: hidden;
        z-index: 250;
    }

    .floating-menu.visible {
        display: block;
        animation: slideUp 0.2s ease-out;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .menu-handle {
        width: 40px;
        height: 4px;
        background: var(--muted);
        border-radius: 2px;
        margin: 0.75rem auto;
    }

    .menu-options {
        padding: 0 0.5rem 0.5rem;
    }

    .menu-option {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        width: 100%;
        padding: 1rem;
        text-align: left;
        background: var(--surface);
        border: none;
        border-radius: 12px;
        font-size: 1rem;
        cursor: pointer;
        margin-bottom: 0.5rem;
        min-height: 56px;
    }

    .menu-option:last-child {
        margin-bottom: 0;
    }

    .menu-option:active {
        background: var(--accent-bg);
    }

    .menu-option.selected {
        background: var(--accent-bg);
        border: 2px solid var(--accent);
    }

    .opt-icon {
        font-size: 1.25rem;
    }

    /* FAB menu toggle */
    .fab-menu-toggle {
        display: none;
        position: fixed;
        bottom: 190px;
        right: 1rem;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: var(--surface);
        border: 1px solid var(--border);
        font-size: 1.5rem;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        z-index: 201;
        transition: all 0.2s;
    }

    .fab-menu-toggle:active,
    .fab-menu-toggle.active {
        background: var(--accent);
        color: white;
    }

    /* Toast */
    .toast {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.8);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 1rem 2rem;
        border-radius: 8px;
        font-size: 1.1rem;
        opacity: 0;
        pointer-events: none;
        transition: all 0.2s;
        z-index: 1000;
    }

    .toast.visible {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: auto;
    }

    .toast.error {
        background: rgba(255, 107, 107, 0.9);
    }

    /* Keyboard shortcuts */
    .keyboard-shortcuts {
        padding: 0.5rem 1rem;
        border-top: 1px solid var(--border);
        font-size: 0.75rem;
        color: var(--muted);
    }

    .keyboard-shortcuts kbd {
        background: var(--surface);
        padding: 2px 6px;
        border-radius: 3px;
        margin: 0 0.25rem;
    }

    /* Responsive: Mobile */
    @media (max-width: 768px) {
        .annotate-review-page {
            height: calc(100vh - 60px);
            padding-bottom: var(--action-bar-height);
        }

        .review-header {
            padding: 0.5rem;
        }

        .review-header h1 {
            font-size: 1rem;
        }

        .frame-list-sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            border-right: none;
            border-bottom: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .frame-list-sidebar.visible {
            transform: translateY(0);
        }

        .sidebar-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 0.5rem 1rem;
            background: var(--surface);
            border: none;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            font-size: 0.875rem;
        }

        .sidebar-toggle .badge {
            background: var(--accent);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .editor-main {
            padding: 0.25rem;
        }

        .desktop-only {
            display: none !important;
        }

        .mobile-help {
            display: block;
        }

        .mobile-action-bar {
            display: block;
        }

        .fab-menu-toggle {
            display: block;
        }

        .canvas-container {
            border-radius: 0;
        }
    }

    /* Desktop only */
    @media (min-width: 769px) {
        .mobile-action-bar {
            display: none;
        }

        .sidebar-toggle {
            display: none;
        }

        .fab-menu-toggle {
            display: none;
        }
    }
</style>
{% endblock %}