services:
  wyze-bridge:
    # Using IDisposable fork for improved performance and camera support
    # See: https://github.com/IDisposable/docker-wyze-bridge
    image: ghcr.io/idisposable/docker-wyze-bridge:latest
    container_name: wyze-bridge
    network_mode: "host"
    environment:
      - TZ=America/Los_Angeles
      - WB_AUTH=false
      - NET_MODE=LAN

      # Performance settings
      - ON_DEMAND=False
      - QUALITY=${WYZE_QUALITY:-HD60}

      - WYZE_EMAIL=${WYZE_EMAIL}
      - WYZE_PASSWORD=${WYZE_PASSWORD}

      # Optional (empty is fine)
      - WYZE_API_KEY=${WYZE_API_KEY:-}
      - WYZE_API_ID=${WYZE_API_ID:-}
      - WYZE_MFA_TYPE=${WYZE_MFA_TYPE:-}
      - WYZE_MFA_CODE=${WYZE_MFA_CODE:-}
      - WYZE_REGION=${WYZE_REGION:-}

    # NOTE: with network_mode: host, "ports:" is ignored by Docker.
    # Keeping it out avoids confusion.
    volumes:
      - ./data/wyze-bridge/tokens:/tokens
      - ./data/wyze-bridge/img:/img
    healthcheck:
      # Using Python for healthcheck since curl/wget may not be in slim image
      test: ["CMD-SHELL", "python -c \"import urllib.request; urllib.request.urlopen('http://localhost:5000', timeout=5)\""]
      interval: 1m
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped

  hbmon-web:
    build:
      context: .
      args:
        # Git commit hash/label shown in the hbmon-web footer; usually set by CI or build scripts.
        # If not provided via the GIT_COMMIT environment variable (e.g. in .env), defaults to "unknown".
        GIT_COMMIT: ${GIT_COMMIT:-unknown}
    container_name: hbmon-web
    command:
      [
        "gunicorn",
        "hbmon.web:app",
        "-k",
        "uvicorn.workers.UvicornWorker",
        "--workers",
        "${HBMON_WEB_WORKERS:-4}",
        "--bind",
        "0.0.0.0:8000",
        "--log-level",
        "info",
        "--access-logfile",
        "-",
        "--error-logfile",
        "-"
      ]
    environment:
      - TZ=America/Los_Angeles

      - HBMON_TITLE=${HBMON_TITLE}
      - HBMON_RTSP_URL=${HBMON_RTSP_URL}

      - HBMON_DATA_DIR=${HBMON_DATA_DIR}
      - HBMON_MEDIA_DIR=${HBMON_MEDIA_DIR}
      - HBMON_CONFIG_PATH=${HBMON_CONFIG_PATH}
      - HBMON_DB_ASYNC_URL=${HBMON_DB_ASYNC_URL:-postgresql+asyncpg://hbmon:hbmon@hbmon-db:5432/hbmon}
      - HBMON_DB_POOL_SIZE=${HBMON_DB_POOL_SIZE:-5}
      - HBMON_DB_MAX_OVERFLOW=${HBMON_DB_MAX_OVERFLOW:-10}
      - HBMON_DB_POOL_TIMEOUT=${HBMON_DB_POOL_TIMEOUT:-30}
      - HBMON_DB_POOL_RECYCLE=${HBMON_DB_POOL_RECYCLE:-1800}
      - HBMON_REDIS_URL=${HBMON_REDIS_URL:-redis://hbmon-redis:6379/0}

    volumes:
      - ./data:/data
    ports:
      - "8000:8000"
    depends_on:
      wyze-bridge:
        condition: service_healthy
      hbmon-db:
        condition: service_healthy
      hbmon-redis:
        condition: service_healthy
    restart: unless-stopped
    # Healthcheck: FastAPI health endpoint
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/api/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  hbmon-stream:
    build:
      context: .
      args:
        # Git commit hash/label shown in the hbmon-web footer; usually set by CI or build scripts.
        # If not provided via the GIT_COMMIT environment variable (e.g. in .env), defaults to "unknown".
        GIT_COMMIT: ${GIT_COMMIT:-unknown}
    container_name: hbmon-stream
    command:
      [
        "gunicorn",
        "hbmon.web:app",
        "-k",
        "uvicorn.workers.UvicornWorker",
        "--workers",
        "1",
        "--bind",
        "0.0.0.0:8001",
        "--log-level",
        "info",
        "--access-logfile",
        "-",
        "--error-logfile",
        "-"
      ]
    environment:
      - TZ=America/Los_Angeles

      - HBMON_TITLE=${HBMON_TITLE}
      - HBMON_RTSP_URL=${HBMON_RTSP_URL}

      - HBMON_DATA_DIR=${HBMON_DATA_DIR}
      - HBMON_MEDIA_DIR=${HBMON_MEDIA_DIR}
      - HBMON_CONFIG_PATH=${HBMON_CONFIG_PATH}
      - HBMON_DB_ASYNC_URL=${HBMON_DB_ASYNC_URL:-postgresql+asyncpg://hbmon:hbmon@hbmon-db:5432/hbmon}
      - HBMON_DB_POOL_SIZE=${HBMON_DB_POOL_SIZE:-5}
      - HBMON_DB_MAX_OVERFLOW=${HBMON_DB_MAX_OVERFLOW:-10}
      - HBMON_DB_POOL_TIMEOUT=${HBMON_DB_POOL_TIMEOUT:-30}
      - HBMON_DB_POOL_RECYCLE=${HBMON_DB_POOL_RECYCLE:-1800}
      - HBMON_REDIS_URL=${HBMON_REDIS_URL:-redis://hbmon-redis:6379/0}

    volumes:
      - ./data:/data
    depends_on:
      wyze-bridge:
        condition: service_healthy
      hbmon-db:
        condition: service_healthy
      hbmon-redis:
        condition: service_healthy
    restart: unless-stopped
    # Healthcheck: FastAPI health endpoint
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8001/api/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  hbmon-worker:
    build: .
    container_name: hbmon-worker
    command: ["python", "-m", "hbmon.worker"]
    environment:
      - TZ=America/Los_Angeles

      - HBMON_RTSP_URL=${HBMON_RTSP_URL}

      - HBMON_DATA_DIR=${HBMON_DATA_DIR}
      - HBMON_MEDIA_DIR=${HBMON_MEDIA_DIR}
      - HBMON_CONFIG_PATH=${HBMON_CONFIG_PATH}
      - HBMON_DB_ASYNC_URL=${HBMON_DB_ASYNC_URL:-postgresql+asyncpg://hbmon:hbmon@hbmon-db:5432/hbmon}
      - HBMON_DB_POOL_SIZE=${HBMON_DB_POOL_SIZE:-5}
      - HBMON_DB_MAX_OVERFLOW=${HBMON_DB_MAX_OVERFLOW:-10}
      - HBMON_DB_POOL_TIMEOUT=${HBMON_DB_POOL_TIMEOUT:-30}
      - HBMON_DB_POOL_RECYCLE=${HBMON_DB_POOL_RECYCLE:-1800}

      - HBMON_CAMERA_NAME=${HBMON_CAMERA_NAME}

      - HBMON_FPS_LIMIT=${HBMON_FPS_LIMIT}
      - HBMON_CLIP_SECONDS=${HBMON_CLIP_SECONDS}

      - HBMON_YOLO_MODEL=${HBMON_YOLO_MODEL}
      - HBMON_DETECT_CONF=${HBMON_DETECT_CONF}
      - HBMON_DETECT_IOU=${HBMON_DETECT_IOU}
      - HBMON_MIN_BOX_AREA=${HBMON_MIN_BOX_AREA}

      - HBMON_COOLDOWN_SECONDS=${HBMON_COOLDOWN_SECONDS}

      - YOLO_CONFIG_DIR=${YOLO_CONFIG_DIR}
      - HBMON_DEBUG_YOLO=${HBMON_DEBUG_YOLO:-0}
      - HBMON_DEBUG_BG=${HBMON_DEBUG_BG:-0}

      - HBMON_MIN_SPECIES_PROB=${HBMON_MIN_SPECIES_PROB}
      - HBMON_MATCH_THRESHOLD=${HBMON_MATCH_THRESHOLD}
      - HBMON_EMA_ALPHA=${HBMON_EMA_ALPHA}

      - HBMON_DEVICE=${HBMON_DEVICE}
      - HBMON_SPECIES_LIST=${HBMON_SPECIES_LIST}

      - HBMON_DEBUG_SAVE_FRAMES=${HBMON_DEBUG_SAVE_FRAMES:-0}
      - HBMON_DEBUG_EVERY_SECONDS=${HBMON_DEBUG_EVERY_SECONDS:-10}
      - HBMON_YOLO_IMGSZ=${HBMON_YOLO_IMGSZ:-1280}

    volumes:
      - ./data:/data
    depends_on:
      wyze-bridge:
        condition: service_healthy
      hbmon-db:
        condition: service_healthy
      hbmon-redis:
        condition: service_healthy
      hbmon-web:
        condition: service_healthy
    restart: unless-stopped
    # Healthcheck: worker is healthy if process is running
    healthcheck:
      test: [ "CMD", "pgrep", "-f", "hbmon.worker" ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  hbmon-proxy:
    image: nginx:alpine
    container_name: hbmon-proxy
    depends_on:
      hbmon-web:
        condition: service_healthy
      hbmon-stream:
        condition: service_healthy
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
    restart: unless-stopped
    # Healthcheck: nginx responds on port 80
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://127.0.0.1/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  hbmon-db:
    image: postgres:16-alpine
    container_name: hbmon-db
    environment:
      - POSTGRES_DB=hbmon
      - POSTGRES_USER=hbmon
      - POSTGRES_PASSWORD=hbmon
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
    healthcheck:
      # pg_isready is the standard healthcheck for the official Postgres image.
      test: ["CMD-SHELL", "pg_isready -U hbmon -d hbmon"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  hbmon-redis:
    image: redis:7-alpine
    container_name: hbmon-redis
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - ./data/redis:/data
    healthcheck:
      # redis-cli ping is the standard healthcheck for the official Redis image.
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
